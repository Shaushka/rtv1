		node->pos.x = ft_atoi(str);
		node->dir.x = ft_atoi(str);
		node->pos.y = ft_atoi(&str[i + 1]);
		node->dir.y = ft_atoi(&str[i + 1]);
		node->pos.z = ft_atoi(&str[i + 1]);
		node->dir.z = ft_atoi(&str[i + 1]);
	obj = parse->obj;
	ft_putendl(parse->name);
	light = parse->light;
	mlx_destroy_image(e->key.interface.mlx, e->key.interface.img.img_ptr);
	mlx_destroy_image(e->mlx_init.mlx, e->mlx_init.img.img_ptr);
	mlx_destroy_window(e->mlx_init.mlx, e->mlx_init.win);
	ft_free_obj_lst(e->scene->l_obj);
	ft_free_light_lst(e->scene->light);
		img.img_ptr = mlx_xpm_file_to_image(e->mlx_init.mlx,
		img.img_ptr = mlx_xpm_file_to_image(e->mlx_init.mlx,
	e->mlx_init.img.img_data[addr + 0] = color.b;
	e->mlx_init.img.img_data[addr + 1] = color.g;
	e->mlx_init.img.img_data[addr + 2] = color.r;
	mlx_put_image_to_window(e->mlx_init.mlx, e->mlx_init.win,
			e->mlx_init.img.img_ptr, 0, 0);
	if (keycode == KEY_COMMAND && e->key.mode != 2)
	else if (keycode == KEY_COMMAND && e->key.mode == 2)
	else if (keycode == KEY_ENTER && e->key.mode == 6)
	else if (keycode == KEY_ENTER && e->key.mode == 5)
	else if (keycode == KEY_ENTER && e->key.mode == 8)
	else if (keycode == KEY_TAB && e->key.mode == 5)
	else if (keycode == KEY_TAB && e->key.mode == 8)
	else if (e->key.mode == 6 && keycode == KEY_R)
		e->ambiant += 0.1;
		mlx_put_image_to_window(e->mlx_init.mlx, e->mlx_init.win,
				e->mlx_init.img.img_ptr, 0, 0);
		e->ambiant -= 0.1;
		mlx_put_image_to_window(e->mlx_init.mlx, e->mlx_init.win,
				e->mlx_init.img.img_ptr, 0, 0);
		t_object *swp = e->scene->l_obj;
	e->mlx_init.mlx = old->mlx_init.mlx;
	e->mlx_init.win = old->mlx_init.win;
	if (!(e->mlx_init.img.img_ptr = mlx_new_image(e->mlx_init.mlx,
	if (!(e->mlx_init.img.img_data = mlx_get_data_addr(e->mlx_init.img.img_ptr,
											&e->mlx_init.img.bpp,
											&e->mlx_init.img.sizeline,
											&e->mlx_init.img.endian)))
	e->mlx_init.img.opp = e->mlx_init.img.bpp / 8;
	if (!(e->mlx_init.mlx = mlx_init()))
	if (!(e->mlx_init.win = mlx_new_window(e->mlx_init.mlx,
	if (!(e->mlx_init.img.img_ptr = mlx_new_image(e->mlx_init.mlx,
	if (!(e->mlx_init.img.img_data = mlx_get_data_addr(e->mlx_init.img.img_ptr,
											&e->mlx_init.img.bpp,
											&e->mlx_init.img.sizeline,
											&e->mlx_init.img.endian)))
	e->mlx_init.img.opp = e->mlx_init.img.bpp / 8;
	e->cam.pos = (t_vector){0., 0., 0.};
	e->cam.dir = unit_vector((t_vector){1., 0., 0.});
	e->ambiant = 0.4;
	mlx_expose_hook(e->mlx_init.win, &expose_hook, e);
	mlx_hook(e->mlx_init.win, BUTTONRELEASE, BUTTONRELEASEMASK, &ft_click, e);
	mlx_hook(e->mlx_init.win, KEYPRESS, KEYPRESSMASK, &key_press_hook, e);
	mlx_loop(e->mlx_init.mlx);
	node->next = NULL;
	node->pos = set_vector(node->pos, 0, 0, 0);
	node->normal = set_vector(node->normal, 0, 0, 0);
	node->dir = set_vector(node->dir, 0, 0, 0);
	node->radius = 0;
	node->height = 0;
	node->shine = 0.0;
	node->checkered = 0;
	node->reflect = 0.0;
	node->refraction = 0.0;
	node->type = NORMAL;
	node->pos = set_vector(node->pos, 0, 0, 0);
	node->dir = set_vector(node->dir, 0, 0, 0);
	node->color = (t_color){0, 0, 0};
	node->intensity = 0;
	node->next = NULL;
	e->scene = malloc(sizeof(t_scene));
	e->scene->l_obj = NULL;
	e->scene->light = NULL;
	inter_pos = add_vector(inter_ray, e->cam.pos);
	tmp = e->scene->l_obj;
	item.color = mult_color(item.color, e->ambiant);
	e->lights = malloc(sizeof(t_light));
	e->lights->pos = (t_vector){0, 4, 0};
	e->lights->dir = (t_vector){0, 1, 0};
	e->lights->color = (t_color){255, 255, 255};
	e->lights->intensity = 0;
	e->lights->next = test;
	light_ray = sub_vector(light.pos, add_vector(inter, e->cam.pos));
	normal = calc_normal(e->cam.pos, item, inter);
	reflect = ray_reflect(calc_normal(e->cam.pos, item, inter), inter);
		tmp = e->cam.pos;
		e->cam.pos = add_vector(inter, tmp);
		c_tmp = check_collision(e, unit_vector(reflect), e->cam.pos);
		e->cam.pos = tmp;
	light_ray = sub_vector(light.pos, add_vector(inter, e->cam.pos));
	normal = calc_normal(e->cam.pos, item, inter);
	mlx_put_image_to_window(e->mlx_init.mlx, e->mlx_init.win,\
					e->mlx_init.img.img_ptr, 0, 0);
	mlx_put_image_to_window(e->mlx_init.mlx, e->mlx_init.win,\
				e->mlx_init.img.img_ptr, 0, 0);
		mlx_destroy_image(e->mlx_init.mlx, e->mlx_init.img.img_ptr);
	parse->name = ft_strdup(file);
	if ((parse->obj = (t_object *)malloc(sizeof(t_object))) == NULL)
	parse->obj->next = NULL;
	e->scene->l_obj = parse->obj;
	e->scene->light = parse->light;
	parse->name = ft_strdup(file);
	if ((parse->obj = (t_object *)malloc(sizeof(t_object))) == NULL)
	if ((parse->light = (t_light *)malloc(sizeof(t_light))) == NULL)
	parse->obj->next = NULL;
	parse->light->next = NULL;
	e->scene->l_obj = parse->obj;
	e->scene->light = parse->light;
	x = e->v_map.win_x;
	y = e->v_map.win_y;
	if ((e->win = mlx_new_window(e->mlx, x, y, "RTv1")) == NULL)
		new_node->family = n;
		new_node->type = ft_strsub(tab[pos], 0, t);
		new_node->value = ft_strsub(tab[pos], t + 1, ft_strlen(tab[pos]));
		new_node->next = NULL;
						parse->obj = tmp_object;
						parse->light = tmp_light;
	if ((parse->nodes = (t_node *)malloc(sizeof(t_node))) == NULL)
	parse->nodes->type = NULL;
	parse->nodes->value = NULL;
	tmp = parse->nodes;
		k = set_node(&(parse->nodes), k, tab);
	sphere->color = (t_color){0, 0, 0};
	sphere->shine = 0;
	sphere->reflect = 0;
	sphere->refraction = 0;
	cone->color = (t_color){0, 0, 0};
	cone->shine = 0;
	cone->refraction = 1.1;
	sphere->next = cylind;
	cone->next = NULL;
	e->scene->l_obj = right_w;
	tmp = e->scene->l_obj;
		return (ft_light(&(*e->lights), *item, mult_vector(ray, inter), e));
   normal = calc_normal(e->cam.pos, item, inter);
tmp = e->cam.pos;
e->cam.pos = add_vector(add_vector(inter, e->cam.pos), mult_vector(refray, 1e-4));
color = add_color(check_collision(e, unit_vector(refray), e->cam.pos), color);
e->cam.pos = tmp;
		norm = calc_normal(e->cam.pos, item, inter);
			tmp = e->cam.pos;
			pos = add_vector(add_vector(inter, e->cam.pos),mult_vector(refray, item.radius));
			e->cam.pos = pos;
			color = add_color(check_collision(e, refray, e->cam.pos), color);
			e->cam.pos = tmp;
	pos_hgv = mult_vector(e->cam.dir, DISTVUE);
	pos_hgv = sub_vector(pos_hgv, mult_vector(e->cam.h, LONGV / 2));
	pos_hgv = add_vector(pos_hgv, mult_vector(e->cam.d, LARGV / 2));
	d = mult_vector(e->cam.d, ((float)(LARGV / (float)SCREEN_W) * (float)x));
	h = mult_vector(e->cam.h, ((float)(LONGV / (float)SCREEN_H) * (float)y));
		addr = y * e->mlx_init.img.sizeline + x * e->mlx_init.img.opp;
		put_pixel_to_img(e, addr, check_collision(e, ray, e->cam.pos));
	e->cam.h = unit_vector((t_vector){0., 0., -1});
	e->cam.d = cross_vector(e->cam.dir, e->cam.h);
